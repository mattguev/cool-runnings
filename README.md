# Runner’s Route Generator

The idea here was to build a program that runners could use to plan their speed work routes. The 3 most common types of speed work are:

- Fartlek: unstructured runs where periods of faster running are mixed with periods of easy-paced or moderate-paced running
- Tempo: sustained effort run that builds up your body’s ability to run faster for longer periods of time
- Interval: alternating short bursts of intense activity with longer periods of less intense activity or even rest.

These training methods improve performance by polishing runners' mechanics and sense of pace. All three require a level of 'flow' which is best achieved by access to a track or treadmill. Otherwise, runners risk spending their entire workout preoccupied with the navigation of unfamiliar terrain. With these factors in mind, the objective was to build a route generator which would eliminate these training barriers and improve beginner race performance by offering three features:

1. Runners could specify any land-based start point in the world.

2. Runners could hypothetically specify any distance, but would ideally choose 1 of the 4 most common World Athletics categories (5K, 10K, 21K, 42K).

3. The route generator would generate the straightest possible route to avoid overwhelming runners with constant directional changes.

The data structures underlying these features were built by loading UBC map data into Python using the OpenStreetMaps API (graph_ubc.gml), then using the networkx and osmnx libraries to represent the map data as a graph where each vertex was a location marker and each node was a path (ubc_map.png). For example:
- Feature A was realized because osmnx allows users to specify a point anywhere in the loaded graph using vertex longitude and latitude markers.
- Feature B was realized because networkx and osmnx can store the total length represented by a set of connected vertices (i.e. a route)
- Feature C was generated by applying a Depth-First Search algorithm to the map data, with a bias toward minimizing the bearing difference (amount of turning) to be done at each vertex.

